'use strict';

var state = require('./state');
var split_trim = require('./util').split_trim;

var prepare = function(commands, options, variables, doc) {
    /* Preset options, commands and optionally a doc.
       This way later only the doc has to be passed to the actual invocation
       as in most cases a client will repeatedly fire up the same *kind* of
       process with new documents.
       */
    if (!commands) {
        throw "ly_client.prepare(): no command argument given"
    };
    state.request.commands = split_trim(commands, ';');

    if (options) {
        state.request.options = split_trim(options);
    }

    if (variables) {
        state.request.variables = split_trim(variables, ';');
    }
    if (doc) {
        state.request.doc = doc;
    }
    state.prepared.params = true;
    state.prepared.cli = false;
    state.prepared.server = false;
};

var prepare_ly = function(command_line) {

}

var make_cli = function() {
    /* Build the array to be passed to spawn the CLI process.
       This is cached.
       */
    if (state.prepared.cli) {
        return;
    }
    // Construct invocation
    state.cl_opts = state.request.options;
    if (state.request.variables) {
        for (var i = 0; i < state.request.variables.length; i++) {
            state.cl_opts.push('-d');
            state.cl_opts.push(state.request.variables[i]);
        };
    };
    if (state.request.commands) {
        state.cl_opts.push(state.request.commands.join(';'));
    };
    state.prepared.cli = true;
}

var make_server = function() {
    /* Build the JSOON object to be passed to the server.
       This is cached.
       */
    if (state.prepared.server) {
        return;
    }
    var j = state.request_json = {};

    // Construct Options object (if present)
    if (state.request.options.length > 0) {
        j.options = {}
        for (var i = 0; i < state.request.options.length; i = i + 2) {
            // Strip leading hyphens in option names
               // TODO: Think if that's the proper way of if we shouldn't
               // send the full option name to the server and handle it there.
            var opt = state.request.options[i].substring(state.request.options[i].lastIndexOf('-') + 1);
            var val = state.request.options[i + 1];
            j.options[opt] = val;
        }
    }

    // Construct Commands object
    j.commands = [];

    var loc_vars = {};
    var cmd = {};
    for (var i = 0; i < state.request.commands.length; i++) {
        cmd = {};
        var cmd_string = state.request.commands[i];
        var sep = cmd_string.indexOf(' ');
        if (sep > -1) {
            // If there's a space in cmd_string it is a command and an args string
            cmd.command = cmd_string.substring(0, sep);
            cmd.args = cmd_string.substring(sep + 1)
        }
        else {
            cmd.command = cmd_string;
        }
        if (cmd.command.indexOf('=') > 0) {
            // We have a variable assignment here, defer to next command
            var entry = cmd.command.split('=');
            loc_vars[entry[0]] = entry[1];
        }
        else {
            // Add command to the array
            if (Object.keys(loc_vars) != 0) {
                // Previous command(s) were variable assignments
                cmd.variables = loc_vars;
                loc_vars = {};
            }
            j.commands.push(cmd);
        }
    }

    if (state.request.variables.length > 0) {
        // Some variable assignments have been prepared, attach them to the
        // first command. NOTE: a variable assignment would override an assignment
        // that is applied in the commands string (but it doesn't make sense to
        // have such duplicate assignments).
        if (!j.commands[0].variables) {
            // init variables key if the command doesn't have variables yet.
            j.commands[0].variables = {};
        };
        for (i = 0; i < state.request.variables.length; i++) {
            var entry = state.request.variables[i].split('=');
            j.commands[0].variables[entry[0]] = entry[1];
        };
    };
    state.prepared.server = true;
};

module.exports = {
    prepare,
    make_cli,
    make_server
}
